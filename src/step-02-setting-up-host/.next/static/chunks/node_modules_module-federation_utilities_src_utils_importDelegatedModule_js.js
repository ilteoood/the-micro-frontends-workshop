"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhost"] = self["webpackChunkhost"] || []).push([["node_modules_module-federation_utilities_src_utils_importDelegatedModule_js"],{

/***/ "../../node_modules/tslib/tslib.es6.js":
/*!*********************************************!*\
  !*** ../../node_modules/tslib/tslib.es6.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __assign: function() { return /* binding */ __assign; },\n/* harmony export */   __asyncDelegator: function() { return /* binding */ __asyncDelegator; },\n/* harmony export */   __asyncGenerator: function() { return /* binding */ __asyncGenerator; },\n/* harmony export */   __asyncValues: function() { return /* binding */ __asyncValues; },\n/* harmony export */   __await: function() { return /* binding */ __await; },\n/* harmony export */   __awaiter: function() { return /* binding */ __awaiter; },\n/* harmony export */   __classPrivateFieldGet: function() { return /* binding */ __classPrivateFieldGet; },\n/* harmony export */   __classPrivateFieldIn: function() { return /* binding */ __classPrivateFieldIn; },\n/* harmony export */   __classPrivateFieldSet: function() { return /* binding */ __classPrivateFieldSet; },\n/* harmony export */   __createBinding: function() { return /* binding */ __createBinding; },\n/* harmony export */   __decorate: function() { return /* binding */ __decorate; },\n/* harmony export */   __exportStar: function() { return /* binding */ __exportStar; },\n/* harmony export */   __extends: function() { return /* binding */ __extends; },\n/* harmony export */   __generator: function() { return /* binding */ __generator; },\n/* harmony export */   __importDefault: function() { return /* binding */ __importDefault; },\n/* harmony export */   __importStar: function() { return /* binding */ __importStar; },\n/* harmony export */   __makeTemplateObject: function() { return /* binding */ __makeTemplateObject; },\n/* harmony export */   __metadata: function() { return /* binding */ __metadata; },\n/* harmony export */   __param: function() { return /* binding */ __param; },\n/* harmony export */   __read: function() { return /* binding */ __read; },\n/* harmony export */   __rest: function() { return /* binding */ __rest; },\n/* harmony export */   __spread: function() { return /* binding */ __spread; },\n/* harmony export */   __spreadArray: function() { return /* binding */ __spreadArray; },\n/* harmony export */   __spreadArrays: function() { return /* binding */ __spreadArrays; },\n/* harmony export */   __values: function() { return /* binding */ __values; }\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nfunction __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ087QUFDUCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUCw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUCxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQ0FBb0M7QUFDckQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxrREFBa0QsUUFBUTtBQUMxRCx5Q0FBeUMsUUFBUTtBQUNqRCx5REFBeUQsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsaUJBQWlCLHVGQUF1RixjQUFjO0FBQ3RILHVCQUF1QixnQ0FBZ0MscUNBQXFDLDJDQUEyQztBQUN2SSw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUIsNkNBQTZDLFVBQVUsc0RBQXNELGNBQWM7QUFDNUksMEJBQTBCLDZCQUE2QixvQkFBb0IsZ0RBQWdELGtCQUFrQjtBQUM3STtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEg7QUFDQTtBQUNPO0FBQ1AsaUNBQWlDLHVDQUF1QyxZQUFZLEtBQUssT0FBTztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZDQUE2QztBQUM3QztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz9mN2EwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcclxuICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcclxuICAgIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/tslib/tslib.es6.js\n"));

/***/ }),

/***/ "../../node_modules/@module-federation/utilities/src/utils/common.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@module-federation/utilities/src/utils/common.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getModule = exports.getContainer = exports.createRuntimeVariables = exports.injectScript = exports.loadScript = exports.createDelegatedModule = exports.extractUrlAndGlobal = exports.remoteVars = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"../../node_modules/tslib/tslib.es6.js\");\nconst getRuntimeRemotes_1 = __webpack_require__(/*! ./getRuntimeRemotes */ \"../../node_modules/@module-federation/utilities/src/utils/getRuntimeRemotes.js\");\nlet remotesFromProcess = {};\ntry {\n    // @ts-ignore\n    remotesFromProcess = ({\"remote\":\"internal /Users/matejaristic/Code/the-micro-frontends-workshop/node_modules/@module-federation/nextjs-mf/src/default-delegate.js?remote=remote@http://localhost:3002/remoteEntry.js\"}) || 0;\n}\ncatch (e) {\n    // not in webpack bundle\n}\nexports.remoteVars = remotesFromProcess;\n// split the @ syntax into url and global\nconst extractUrlAndGlobal = (urlAndGlobal) => {\n    const index = urlAndGlobal.indexOf('@');\n    if (index <= 0 || index === urlAndGlobal.length - 1) {\n        throw new Error(`Invalid request \"${urlAndGlobal}\"`);\n    }\n    return [urlAndGlobal.substring(index + 1), urlAndGlobal.substring(0, index)];\n};\nexports.extractUrlAndGlobal = extractUrlAndGlobal;\nconst createDelegatedModule = (delegate, params) => {\n    const queries = [];\n    for (const [key, value] of Object.entries(params)) {\n        if (Array.isArray(value) || typeof value === 'object') {\n            throw new Error(`[Module Federation] Delegated module params cannot be an array or object. Key \"${key}\" should be a string or number`);\n        }\n        queries.push(`${key}=${value}`);\n    }\n    if (queries.length === 0)\n        return `internal ${delegate}`;\n    return `internal ${delegate}?${queries.join('&')}`;\n};\nexports.createDelegatedModule = createDelegatedModule;\nconst loadScript = (keyOrRuntimeRemoteItem) => {\n    const runtimeRemotes = (0, getRuntimeRemotes_1.getRuntimeRemotes)();\n    // 1) Load remote container if needed\n    let asyncContainer;\n    const reference = typeof keyOrRuntimeRemoteItem === 'string'\n        ? runtimeRemotes[keyOrRuntimeRemoteItem]\n        : keyOrRuntimeRemoteItem;\n    if (reference.asyncContainer) {\n        asyncContainer =\n            typeof reference.asyncContainer.then === 'function'\n                ? reference.asyncContainer\n                : // @ts-ignore\n                    reference.asyncContainer();\n    }\n    else {\n        // This casting is just to satisfy typescript,\n        // In reality remoteGlobal will always be a string;\n        const remoteGlobal = reference.global;\n        // Check if theres an override for container key if not use remote global\n        const containerKey = reference.uniqueKey\n            ? reference.uniqueKey\n            : remoteGlobal;\n        const __webpack_error__ = new Error();\n        // @ts-ignore\n        if (!globalThis.__remote_scope__) {\n            // create a global scope for container, similar to how remotes are set on window in the browser\n            // @ts-ignore\n            globalThis.__remote_scope__ = {\n                // @ts-ignore\n                _config: {},\n            };\n        }\n        // @ts-ignore\n        const globalScope = \n        // @ts-ignore\n        typeof window !== 'undefined' ? window : globalThis.__remote_scope__;\n        if (typeof window === 'undefined') {\n            globalScope['_config'][containerKey] = reference.url;\n        }\n        else {\n            // to match promise template system, can be removed once promise template is gone\n            if (!globalScope['remoteLoading']) {\n                globalScope['remoteLoading'] = {};\n            }\n            if (globalScope['remoteLoading'][containerKey]) {\n                return globalScope['remoteLoading'][containerKey];\n            }\n        }\n        // @ts-ignore\n        asyncContainer = new Promise(function (resolve, reject) {\n            function resolveRemoteGlobal() {\n                const asyncContainer = globalScope[remoteGlobal];\n                return resolve(asyncContainer);\n            }\n            if (typeof globalScope[remoteGlobal] !== 'undefined') {\n                return resolveRemoteGlobal();\n            }\n            __webpack_require__.l(reference.url, function (event) {\n                if (typeof globalScope[remoteGlobal] !== 'undefined') {\n                    return resolveRemoteGlobal();\n                }\n                const errorType = event && (event.type === 'load' ? 'missing' : event.type);\n                const realSrc = event && event.target && event.target.src;\n                __webpack_error__.message =\n                    'Loading script failed.\\n(' +\n                        errorType +\n                        ': ' +\n                        realSrc +\n                        ' or global var ' +\n                        remoteGlobal +\n                        ')';\n                __webpack_error__.name = 'ScriptExternalLoadError';\n                __webpack_error__.type = errorType;\n                __webpack_error__.request = realSrc;\n                reject(__webpack_error__);\n            }, containerKey);\n        }).catch(function (err) {\n            console.error('container is offline, returning fake remote');\n            console.error(err);\n            return {\n                fake: true,\n                // @ts-ignore\n                get: (arg) => {\n                    console.warn('faking', arg, 'module on, its offline');\n                    return Promise.resolve(() => {\n                        return {\n                            __esModule: true,\n                            default: () => {\n                                return null;\n                            },\n                        };\n                    });\n                },\n                //eslint-disable-next-line\n                init: () => { },\n            };\n        });\n        if (typeof window !== 'undefined') {\n            globalScope['remoteLoading'][containerKey] = asyncContainer;\n        }\n    }\n    return asyncContainer;\n};\nexports.loadScript = loadScript;\nconst createContainerSharingScope = (asyncContainer) => {\n    // @ts-ignore\n    return asyncContainer\n        .then(function (container) {\n        if (!__webpack_require__.S['default']) {\n            // not always a promise, so we wrap it in a resolve\n            return Promise.resolve(__webpack_require__.I('default')).then(function () {\n                return container;\n            });\n        }\n        else {\n            return container;\n        }\n    })\n        .then(function (container) {\n        try {\n            // WARNING: here might be a potential BUG.\n            //   `container.init` does not return a Promise, and here we do not call `then` on it.\n            // But according to [docs](https://webpack.js.org/concepts/module-federation/#dynamic-remote-containers)\n            //   it must be async.\n            // The problem may be in Proxy in NextFederationPlugin.js.\n            //   or maybe a bug in the webpack itself - instead of returning rejected promise it just throws an error.\n            // But now everything works properly and we keep this code as is.\n            container.init(__webpack_require__.S['default']);\n        }\n        catch (e) {\n            // maybe container already initialized so nothing to throw\n        }\n        return container;\n    });\n};\n/**\n * Return initialized remote container by remote's key or its runtime remote item data.\n *\n * `runtimeRemoteItem` might be\n *    { global, url } - values obtained from webpack remotes option `global@url`\n * or\n *    { asyncContainer } - async container is a promise that resolves to the remote container\n */\nconst injectScript = (keyOrRuntimeRemoteItem) => {\n    const asyncContainer = (0, exports.loadScript)(keyOrRuntimeRemoteItem);\n    return createContainerSharingScope(asyncContainer);\n};\nexports.injectScript = injectScript;\nconst createRuntimeVariables = (remotes) => {\n    if (!remotes) {\n        return {};\n    }\n    return Object.entries(remotes).reduce((acc, remote) => {\n        // handle promise new promise and external new promise\n        if (remote[1].startsWith('promise ') || remote[1].startsWith('external ')) {\n            const promiseCall = remote[1]\n                .replace('promise ', '')\n                .replace('external ', '');\n            acc[remote[0]] = `function() {\n        return ${promiseCall}\n      }`;\n            return acc;\n        }\n        // if somehow its just the @ syntax or something else, pass it through\n        acc[remote[0]] = JSON.stringify(remote[1]);\n        return acc;\n    }, {});\n};\nexports.createRuntimeVariables = createRuntimeVariables;\n/**\n * Returns initialized webpack RemoteContainer.\n * If its' script does not loaded - then load & init it firstly.\n */\nconst getContainer = (remoteContainer) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {\n    if (!remoteContainer) {\n        throw Error(`Remote container options is empty`);\n    }\n    // @ts-ignore\n    const containerScope = \n    // @ts-ignore\n    typeof window !== 'undefined' ? window : globalThis.__remote_scope__;\n    if (typeof remoteContainer === 'string') {\n        if (containerScope[remoteContainer]) {\n            return containerScope[remoteContainer];\n        }\n        return;\n    }\n    else {\n        const uniqueKey = remoteContainer.uniqueKey;\n        if (containerScope[uniqueKey]) {\n            return containerScope[uniqueKey];\n        }\n        const container = yield (0, exports.injectScript)({\n            global: remoteContainer.global,\n            url: remoteContainer.url,\n        });\n        if (container) {\n            return container;\n        }\n        throw Error(`Remote container ${remoteContainer.url} is empty`);\n    }\n});\nexports.getContainer = getContainer;\n/**\n * Return remote module from container.\n * If you provide `exportName` it automatically return exact property value from module.\n *\n * @example\n *   remote.getModule('./pages/index', 'default')\n */\nconst getModule = ({ remoteContainer, modulePath, exportName, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {\n    const container = yield (0, exports.getContainer)(remoteContainer);\n    try {\n        const modFactory = yield (container === null || container === void 0 ? void 0 : container.get(modulePath));\n        if (!modFactory)\n            return undefined;\n        const mod = modFactory();\n        if (exportName) {\n            return mod && typeof mod === 'object' ? mod[exportName] : undefined;\n        }\n        else {\n            return mod;\n        }\n    }\n    catch (error) {\n        console.error(error);\n        return undefined;\n    }\n});\nexports.getModule = getModule;\n//# sourceMappingURL=common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi91dGlsaXRpZXMvc3JjL3V0aWxzL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLDhCQUE4QixHQUFHLG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLDZCQUE2QixHQUFHLDJCQUEyQixHQUFHLGtCQUFrQjtBQUN4TSxnQkFBZ0IsbUJBQU8sQ0FBQyxvREFBTztBQUMvQiw0QkFBNEIsbUJBQU8sQ0FBQywyR0FBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtNQUFzQixJQUFJLENBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEcsSUFBSTtBQUNsSDtBQUNBLHdCQUF3QixJQUFJLEdBQUcsTUFBTTtBQUNyQztBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEMsdUJBQXVCLFNBQVMsR0FBRyxrQkFBa0I7QUFDckQ7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXdCO0FBQ3JDO0FBQ0EsbUNBQW1DLHFCQUF3QjtBQUMzRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsY0FBYztBQUN0QjtBQUNBLFFBQVEsaUJBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBLENBQUM7QUFDRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQTBDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9zdC8uLi8uLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3V0aWxpdGllcy9zcmMvdXRpbHMvY29tbW9uLmpzPzA5MWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0TW9kdWxlID0gZXhwb3J0cy5nZXRDb250YWluZXIgPSBleHBvcnRzLmNyZWF0ZVJ1bnRpbWVWYXJpYWJsZXMgPSBleHBvcnRzLmluamVjdFNjcmlwdCA9IGV4cG9ydHMubG9hZFNjcmlwdCA9IGV4cG9ydHMuY3JlYXRlRGVsZWdhdGVkTW9kdWxlID0gZXhwb3J0cy5leHRyYWN0VXJsQW5kR2xvYmFsID0gZXhwb3J0cy5yZW1vdGVWYXJzID0gdm9pZCAwO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmNvbnN0IGdldFJ1bnRpbWVSZW1vdGVzXzEgPSByZXF1aXJlKFwiLi9nZXRSdW50aW1lUmVtb3Rlc1wiKTtcbmxldCByZW1vdGVzRnJvbVByb2Nlc3MgPSB7fTtcbnRyeSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJlbW90ZXNGcm9tUHJvY2VzcyA9IHByb2Nlc3MuZW52WydSRU1PVEVTJ10gfHwge307XG59XG5jYXRjaCAoZSkge1xuICAgIC8vIG5vdCBpbiB3ZWJwYWNrIGJ1bmRsZVxufVxuZXhwb3J0cy5yZW1vdGVWYXJzID0gcmVtb3Rlc0Zyb21Qcm9jZXNzO1xuLy8gc3BsaXQgdGhlIEAgc3ludGF4IGludG8gdXJsIGFuZCBnbG9iYWxcbmNvbnN0IGV4dHJhY3RVcmxBbmRHbG9iYWwgPSAodXJsQW5kR2xvYmFsKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSB1cmxBbmRHbG9iYWwuaW5kZXhPZignQCcpO1xuICAgIGlmIChpbmRleCA8PSAwIHx8IGluZGV4ID09PSB1cmxBbmRHbG9iYWwubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVxdWVzdCBcIiR7dXJsQW5kR2xvYmFsfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBbdXJsQW5kR2xvYmFsLnN1YnN0cmluZyhpbmRleCArIDEpLCB1cmxBbmRHbG9iYWwuc3Vic3RyaW5nKDAsIGluZGV4KV07XG59O1xuZXhwb3J0cy5leHRyYWN0VXJsQW5kR2xvYmFsID0gZXh0cmFjdFVybEFuZEdsb2JhbDtcbmNvbnN0IGNyZWF0ZURlbGVnYXRlZE1vZHVsZSA9IChkZWxlZ2F0ZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgcXVlcmllcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW01vZHVsZSBGZWRlcmF0aW9uXSBEZWxlZ2F0ZWQgbW9kdWxlIHBhcmFtcyBjYW5ub3QgYmUgYW4gYXJyYXkgb3Igb2JqZWN0LiBLZXkgXCIke2tleX1cIiBzaG91bGQgYmUgYSBzdHJpbmcgb3IgbnVtYmVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcmllcy5wdXNoKGAke2tleX09JHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJpZXMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gYGludGVybmFsICR7ZGVsZWdhdGV9YDtcbiAgICByZXR1cm4gYGludGVybmFsICR7ZGVsZWdhdGV9PyR7cXVlcmllcy5qb2luKCcmJyl9YDtcbn07XG5leHBvcnRzLmNyZWF0ZURlbGVnYXRlZE1vZHVsZSA9IGNyZWF0ZURlbGVnYXRlZE1vZHVsZTtcbmNvbnN0IGxvYWRTY3JpcHQgPSAoa2V5T3JSdW50aW1lUmVtb3RlSXRlbSkgPT4ge1xuICAgIGNvbnN0IHJ1bnRpbWVSZW1vdGVzID0gKDAsIGdldFJ1bnRpbWVSZW1vdGVzXzEuZ2V0UnVudGltZVJlbW90ZXMpKCk7XG4gICAgLy8gMSkgTG9hZCByZW1vdGUgY29udGFpbmVyIGlmIG5lZWRlZFxuICAgIGxldCBhc3luY0NvbnRhaW5lcjtcbiAgICBjb25zdCByZWZlcmVuY2UgPSB0eXBlb2Yga2V5T3JSdW50aW1lUmVtb3RlSXRlbSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBydW50aW1lUmVtb3Rlc1trZXlPclJ1bnRpbWVSZW1vdGVJdGVtXVxuICAgICAgICA6IGtleU9yUnVudGltZVJlbW90ZUl0ZW07XG4gICAgaWYgKHJlZmVyZW5jZS5hc3luY0NvbnRhaW5lcikge1xuICAgICAgICBhc3luY0NvbnRhaW5lciA9XG4gICAgICAgICAgICB0eXBlb2YgcmVmZXJlbmNlLmFzeW5jQ29udGFpbmVyLnRoZW4gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IHJlZmVyZW5jZS5hc3luY0NvbnRhaW5lclxuICAgICAgICAgICAgICAgIDogLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2UuYXN5bmNDb250YWluZXIoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgY2FzdGluZyBpcyBqdXN0IHRvIHNhdGlzZnkgdHlwZXNjcmlwdCxcbiAgICAgICAgLy8gSW4gcmVhbGl0eSByZW1vdGVHbG9iYWwgd2lsbCBhbHdheXMgYmUgYSBzdHJpbmc7XG4gICAgICAgIGNvbnN0IHJlbW90ZUdsb2JhbCA9IHJlZmVyZW5jZS5nbG9iYWw7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlcyBhbiBvdmVycmlkZSBmb3IgY29udGFpbmVyIGtleSBpZiBub3QgdXNlIHJlbW90ZSBnbG9iYWxcbiAgICAgICAgY29uc3QgY29udGFpbmVyS2V5ID0gcmVmZXJlbmNlLnVuaXF1ZUtleVxuICAgICAgICAgICAgPyByZWZlcmVuY2UudW5pcXVlS2V5XG4gICAgICAgICAgICA6IHJlbW90ZUdsb2JhbDtcbiAgICAgICAgY29uc3QgX193ZWJwYWNrX2Vycm9yX18gPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoIWdsb2JhbFRoaXMuX19yZW1vdGVfc2NvcGVfXykge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGEgZ2xvYmFsIHNjb3BlIGZvciBjb250YWluZXIsIHNpbWlsYXIgdG8gaG93IHJlbW90ZXMgYXJlIHNldCBvbiB3aW5kb3cgaW4gdGhlIGJyb3dzZXJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuX19yZW1vdGVfc2NvcGVfXyA9IHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgX2NvbmZpZzoge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgZ2xvYmFsU2NvcGUgPSBcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbFRoaXMuX19yZW1vdGVfc2NvcGVfXztcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBnbG9iYWxTY29wZVsnX2NvbmZpZyddW2NvbnRhaW5lcktleV0gPSByZWZlcmVuY2UudXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdG8gbWF0Y2ggcHJvbWlzZSB0ZW1wbGF0ZSBzeXN0ZW0sIGNhbiBiZSByZW1vdmVkIG9uY2UgcHJvbWlzZSB0ZW1wbGF0ZSBpcyBnb25lXG4gICAgICAgICAgICBpZiAoIWdsb2JhbFNjb3BlWydyZW1vdGVMb2FkaW5nJ10pIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxTY29wZVsncmVtb3RlTG9hZGluZyddID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2xvYmFsU2NvcGVbJ3JlbW90ZUxvYWRpbmcnXVtjb250YWluZXJLZXldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFNjb3BlWydyZW1vdGVMb2FkaW5nJ11bY29udGFpbmVyS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGFzeW5jQ29udGFpbmVyID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZVJlbW90ZUdsb2JhbCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhc3luY0NvbnRhaW5lciA9IGdsb2JhbFNjb3BlW3JlbW90ZUdsb2JhbF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoYXN5bmNDb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxTY29wZVtyZW1vdGVHbG9iYWxdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlUmVtb3RlR2xvYmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmwocmVmZXJlbmNlLnVybCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxTY29wZVtyZW1vdGVHbG9iYWxdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVJlbW90ZUdsb2JhbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhbFNyYyA9IGV2ZW50ICYmIGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQuc3JjO1xuICAgICAgICAgICAgICAgIF9fd2VicGFja19lcnJvcl9fLm1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICAgICAnTG9hZGluZyBzY3JpcHQgZmFpbGVkLlxcbignICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yVHlwZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWxTcmMgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyBvciBnbG9iYWwgdmFyICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlR2xvYmFsICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcpJztcbiAgICAgICAgICAgICAgICBfX3dlYnBhY2tfZXJyb3JfXy5uYW1lID0gJ1NjcmlwdEV4dGVybmFsTG9hZEVycm9yJztcbiAgICAgICAgICAgICAgICBfX3dlYnBhY2tfZXJyb3JfXy50eXBlID0gZXJyb3JUeXBlO1xuICAgICAgICAgICAgICAgIF9fd2VicGFja19lcnJvcl9fLnJlcXVlc3QgPSByZWFsU3JjO1xuICAgICAgICAgICAgICAgIHJlamVjdChfX3dlYnBhY2tfZXJyb3JfXyk7XG4gICAgICAgICAgICB9LCBjb250YWluZXJLZXkpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdjb250YWluZXIgaXMgb2ZmbGluZSwgcmV0dXJuaW5nIGZha2UgcmVtb3RlJyk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZha2U6IHRydWUsXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGdldDogKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2Zha2luZycsIGFyZywgJ21vZHVsZSBvbiwgaXRzIG9mZmxpbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZXNNb2R1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIGluaXQ6ICgpID0+IHsgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlWydyZW1vdGVMb2FkaW5nJ11bY29udGFpbmVyS2V5XSA9IGFzeW5jQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhc3luY0NvbnRhaW5lcjtcbn07XG5leHBvcnRzLmxvYWRTY3JpcHQgPSBsb2FkU2NyaXB0O1xuY29uc3QgY3JlYXRlQ29udGFpbmVyU2hhcmluZ1Njb3BlID0gKGFzeW5jQ29udGFpbmVyKSA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBhc3luY0NvbnRhaW5lclxuICAgICAgICAudGhlbihmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgIGlmICghX193ZWJwYWNrX3NoYXJlX3Njb3Blc19fWydkZWZhdWx0J10pIHtcbiAgICAgICAgICAgIC8vIG5vdCBhbHdheXMgYSBwcm9taXNlLCBzbyB3ZSB3cmFwIGl0IGluIGEgcmVzb2x2ZVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfX3dlYnBhY2tfaW5pdF9zaGFyaW5nX18oJ2RlZmF1bHQnKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdBUk5JTkc6IGhlcmUgbWlnaHQgYmUgYSBwb3RlbnRpYWwgQlVHLlxuICAgICAgICAgICAgLy8gICBgY29udGFpbmVyLmluaXRgIGRvZXMgbm90IHJldHVybiBhIFByb21pc2UsIGFuZCBoZXJlIHdlIGRvIG5vdCBjYWxsIGB0aGVuYCBvbiBpdC5cbiAgICAgICAgICAgIC8vIEJ1dCBhY2NvcmRpbmcgdG8gW2RvY3NdKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uY2VwdHMvbW9kdWxlLWZlZGVyYXRpb24vI2R5bmFtaWMtcmVtb3RlLWNvbnRhaW5lcnMpXG4gICAgICAgICAgICAvLyAgIGl0IG11c3QgYmUgYXN5bmMuXG4gICAgICAgICAgICAvLyBUaGUgcHJvYmxlbSBtYXkgYmUgaW4gUHJveHkgaW4gTmV4dEZlZGVyYXRpb25QbHVnaW4uanMuXG4gICAgICAgICAgICAvLyAgIG9yIG1heWJlIGEgYnVnIGluIHRoZSB3ZWJwYWNrIGl0c2VsZiAtIGluc3RlYWQgb2YgcmV0dXJuaW5nIHJlamVjdGVkIHByb21pc2UgaXQganVzdCB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgICAgICAvLyBCdXQgbm93IGV2ZXJ5dGhpbmcgd29ya3MgcHJvcGVybHkgYW5kIHdlIGtlZXAgdGhpcyBjb2RlIGFzIGlzLlxuICAgICAgICAgICAgY29udGFpbmVyLmluaXQoX193ZWJwYWNrX3NoYXJlX3Njb3Blc19fWydkZWZhdWx0J10pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBtYXliZSBjb250YWluZXIgYWxyZWFkeSBpbml0aWFsaXplZCBzbyBub3RoaW5nIHRvIHRocm93XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9KTtcbn07XG4vKipcbiAqIFJldHVybiBpbml0aWFsaXplZCByZW1vdGUgY29udGFpbmVyIGJ5IHJlbW90ZSdzIGtleSBvciBpdHMgcnVudGltZSByZW1vdGUgaXRlbSBkYXRhLlxuICpcbiAqIGBydW50aW1lUmVtb3RlSXRlbWAgbWlnaHQgYmVcbiAqICAgIHsgZ2xvYmFsLCB1cmwgfSAtIHZhbHVlcyBvYnRhaW5lZCBmcm9tIHdlYnBhY2sgcmVtb3RlcyBvcHRpb24gYGdsb2JhbEB1cmxgXG4gKiBvclxuICogICAgeyBhc3luY0NvbnRhaW5lciB9IC0gYXN5bmMgY29udGFpbmVyIGlzIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZW1vdGUgY29udGFpbmVyXG4gKi9cbmNvbnN0IGluamVjdFNjcmlwdCA9IChrZXlPclJ1bnRpbWVSZW1vdGVJdGVtKSA9PiB7XG4gICAgY29uc3QgYXN5bmNDb250YWluZXIgPSAoMCwgZXhwb3J0cy5sb2FkU2NyaXB0KShrZXlPclJ1bnRpbWVSZW1vdGVJdGVtKTtcbiAgICByZXR1cm4gY3JlYXRlQ29udGFpbmVyU2hhcmluZ1Njb3BlKGFzeW5jQ29udGFpbmVyKTtcbn07XG5leHBvcnRzLmluamVjdFNjcmlwdCA9IGluamVjdFNjcmlwdDtcbmNvbnN0IGNyZWF0ZVJ1bnRpbWVWYXJpYWJsZXMgPSAocmVtb3RlcykgPT4ge1xuICAgIGlmICghcmVtb3Rlcykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhyZW1vdGVzKS5yZWR1Y2UoKGFjYywgcmVtb3RlKSA9PiB7XG4gICAgICAgIC8vIGhhbmRsZSBwcm9taXNlIG5ldyBwcm9taXNlIGFuZCBleHRlcm5hbCBuZXcgcHJvbWlzZVxuICAgICAgICBpZiAocmVtb3RlWzFdLnN0YXJ0c1dpdGgoJ3Byb21pc2UgJykgfHwgcmVtb3RlWzFdLnN0YXJ0c1dpdGgoJ2V4dGVybmFsICcpKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlQ2FsbCA9IHJlbW90ZVsxXVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdwcm9taXNlICcsICcnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdleHRlcm5hbCAnLCAnJyk7XG4gICAgICAgICAgICBhY2NbcmVtb3RlWzBdXSA9IGBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICR7cHJvbWlzZUNhbGx9XG4gICAgICB9YDtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgc29tZWhvdyBpdHMganVzdCB0aGUgQCBzeW50YXggb3Igc29tZXRoaW5nIGVsc2UsIHBhc3MgaXQgdGhyb3VnaFxuICAgICAgICBhY2NbcmVtb3RlWzBdXSA9IEpTT04uc3RyaW5naWZ5KHJlbW90ZVsxXSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufTtcbmV4cG9ydHMuY3JlYXRlUnVudGltZVZhcmlhYmxlcyA9IGNyZWF0ZVJ1bnRpbWVWYXJpYWJsZXM7XG4vKipcbiAqIFJldHVybnMgaW5pdGlhbGl6ZWQgd2VicGFjayBSZW1vdGVDb250YWluZXIuXG4gKiBJZiBpdHMnIHNjcmlwdCBkb2VzIG5vdCBsb2FkZWQgLSB0aGVuIGxvYWQgJiBpbml0IGl0IGZpcnN0bHkuXG4gKi9cbmNvbnN0IGdldENvbnRhaW5lciA9IChyZW1vdGVDb250YWluZXIpID0+IHRzbGliXzEuX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKCFyZW1vdGVDb250YWluZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFJlbW90ZSBjb250YWluZXIgb3B0aW9ucyBpcyBlbXB0eWApO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgY29udGFpbmVyU2NvcGUgPSBcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWxUaGlzLl9fcmVtb3RlX3Njb3BlX187XG4gICAgaWYgKHR5cGVvZiByZW1vdGVDb250YWluZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChjb250YWluZXJTY29wZVtyZW1vdGVDb250YWluZXJdKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyU2NvcGVbcmVtb3RlQ29udGFpbmVyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB1bmlxdWVLZXkgPSByZW1vdGVDb250YWluZXIudW5pcXVlS2V5O1xuICAgICAgICBpZiAoY29udGFpbmVyU2NvcGVbdW5pcXVlS2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lclNjb3BlW3VuaXF1ZUtleV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0geWllbGQgKDAsIGV4cG9ydHMuaW5qZWN0U2NyaXB0KSh7XG4gICAgICAgICAgICBnbG9iYWw6IHJlbW90ZUNvbnRhaW5lci5nbG9iYWwsXG4gICAgICAgICAgICB1cmw6IHJlbW90ZUNvbnRhaW5lci51cmwsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IEVycm9yKGBSZW1vdGUgY29udGFpbmVyICR7cmVtb3RlQ29udGFpbmVyLnVybH0gaXMgZW1wdHlgKTtcbiAgICB9XG59KTtcbmV4cG9ydHMuZ2V0Q29udGFpbmVyID0gZ2V0Q29udGFpbmVyO1xuLyoqXG4gKiBSZXR1cm4gcmVtb3RlIG1vZHVsZSBmcm9tIGNvbnRhaW5lci5cbiAqIElmIHlvdSBwcm92aWRlIGBleHBvcnROYW1lYCBpdCBhdXRvbWF0aWNhbGx5IHJldHVybiBleGFjdCBwcm9wZXJ0eSB2YWx1ZSBmcm9tIG1vZHVsZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogICByZW1vdGUuZ2V0TW9kdWxlKCcuL3BhZ2VzL2luZGV4JywgJ2RlZmF1bHQnKVxuICovXG5jb25zdCBnZXRNb2R1bGUgPSAoeyByZW1vdGVDb250YWluZXIsIG1vZHVsZVBhdGgsIGV4cG9ydE5hbWUsIH0pID0+IHRzbGliXzEuX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0geWllbGQgKDAsIGV4cG9ydHMuZ2V0Q29udGFpbmVyKShyZW1vdGVDb250YWluZXIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1vZEZhY3RvcnkgPSB5aWVsZCAoY29udGFpbmVyID09PSBudWxsIHx8IGNvbnRhaW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGFpbmVyLmdldChtb2R1bGVQYXRoKSk7XG4gICAgICAgIGlmICghbW9kRmFjdG9yeSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IG1vZCA9IG1vZEZhY3RvcnkoKTtcbiAgICAgICAgaWYgKGV4cG9ydE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2QgJiYgdHlwZW9mIG1vZCA9PT0gJ29iamVjdCcgPyBtb2RbZXhwb3J0TmFtZV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59KTtcbmV4cG9ydHMuZ2V0TW9kdWxlID0gZ2V0TW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@module-federation/utilities/src/utils/common.js\n"));

/***/ }),

/***/ "../../node_modules/@module-federation/utilities/src/utils/getRuntimeRemotes.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/@module-federation/utilities/src/utils/getRuntimeRemotes.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getRuntimeRemotes = void 0;\nconst common_1 = __webpack_require__(/*! ./common */ \"../../node_modules/@module-federation/utilities/src/utils/common.js\");\nconst getRuntimeRemotes = () => {\n    try {\n        const runtimeRemotes = Object.entries(common_1.remoteVars).reduce(function (acc, item) {\n            const [key, value] = item;\n            // if its an object with a thenable (eagerly executing function)\n            if (typeof value === 'object' && typeof value.then === 'function') {\n                acc[key] = { asyncContainer: value };\n            }\n            // if its a function that must be called (lazily executing function)\n            else if (typeof value === 'function') {\n                // @ts-ignore\n                acc[key] = { asyncContainer: value };\n            }\n            // if its a delegate module, skip it\n            else if (typeof value === 'string' && value.startsWith('internal ')) {\n                const [request, query] = value.replace('internal ', '').split('?');\n                if (query) {\n                    const remoteSyntax = new URLSearchParams(query).get('remote');\n                    if (remoteSyntax) {\n                        const [url, global] = (0, common_1.extractUrlAndGlobal)(remoteSyntax);\n                        acc[key] = { global, url };\n                    }\n                }\n            }\n            // if its just a string (global@url)\n            else if (typeof value === 'string') {\n                const [url, global] = (0, common_1.extractUrlAndGlobal)(value);\n                acc[key] = { global, url };\n            }\n            // we dont know or currently support this type\n            else {\n                //@ts-ignore\n                console.warn('remotes process', ({\"remote\":\"internal /Users/matejaristic/Code/the-micro-frontends-workshop/node_modules/@module-federation/nextjs-mf/src/default-delegate.js?remote=remote@http://localhost:3002/remoteEntry.js\"}));\n                throw new Error(`[mf] Invalid value received for runtime_remote \"${key}\"`);\n            }\n            return acc;\n        }, {});\n        return runtimeRemotes;\n    }\n    catch (err) {\n        console.warn('Unable to retrieve runtime remotes: ', err);\n    }\n    return {};\n};\nexports.getRuntimeRemotes = getRuntimeRemotes;\n//# sourceMappingURL=getRuntimeRemotes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi91dGlsaXRpZXMvc3JjL3V0aWxzL2dldFJ1bnRpbWVSZW1vdGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QixpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa01BQW1CO0FBQ25FLG1GQUFtRixJQUFJO0FBQ3ZGO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi91dGlsaXRpZXMvc3JjL3V0aWxzL2dldFJ1bnRpbWVSZW1vdGVzLmpzPzdjOWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFJ1bnRpbWVSZW1vdGVzID0gdm9pZCAwO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG5jb25zdCBnZXRSdW50aW1lUmVtb3RlcyA9ICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBydW50aW1lUmVtb3RlcyA9IE9iamVjdC5lbnRyaWVzKGNvbW1vbl8xLnJlbW90ZVZhcnMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBpdGVtKSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBpdGVtO1xuICAgICAgICAgICAgLy8gaWYgaXRzIGFuIG9iamVjdCB3aXRoIGEgdGhlbmFibGUgKGVhZ2VybHkgZXhlY3V0aW5nIGZ1bmN0aW9uKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IHsgYXN5bmNDb250YWluZXI6IHZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBpdHMgYSBmdW5jdGlvbiB0aGF0IG11c3QgYmUgY2FsbGVkIChsYXppbHkgZXhlY3V0aW5nIGZ1bmN0aW9uKVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGFjY1trZXldID0geyBhc3luY0NvbnRhaW5lcjogdmFsdWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGl0cyBhIGRlbGVnYXRlIG1vZHVsZSwgc2tpcCBpdFxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5zdGFydHNXaXRoKCdpbnRlcm5hbCAnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtyZXF1ZXN0LCBxdWVyeV0gPSB2YWx1ZS5yZXBsYWNlKCdpbnRlcm5hbCAnLCAnJykuc3BsaXQoJz8nKTtcbiAgICAgICAgICAgICAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtb3RlU3ludGF4ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhxdWVyeSkuZ2V0KCdyZW1vdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW90ZVN5bnRheCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3VybCwgZ2xvYmFsXSA9ICgwLCBjb21tb25fMS5leHRyYWN0VXJsQW5kR2xvYmFsKShyZW1vdGVTeW50YXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjW2tleV0gPSB7IGdsb2JhbCwgdXJsIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBpdHMganVzdCBhIHN0cmluZyAoZ2xvYmFsQHVybClcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbdXJsLCBnbG9iYWxdID0gKDAsIGNvbW1vbl8xLmV4dHJhY3RVcmxBbmRHbG9iYWwpKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IHsgZ2xvYmFsLCB1cmwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGRvbnQga25vdyBvciBjdXJyZW50bHkgc3VwcG9ydCB0aGlzIHR5cGVcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigncmVtb3RlcyBwcm9jZXNzJywgcHJvY2Vzcy5lbnYuUkVNT1RFUyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbbWZdIEludmFsaWQgdmFsdWUgcmVjZWl2ZWQgZm9yIHJ1bnRpbWVfcmVtb3RlIFwiJHtrZXl9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIHJ1bnRpbWVSZW1vdGVzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIHJldHJpZXZlIHJ1bnRpbWUgcmVtb3RlczogJywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufTtcbmV4cG9ydHMuZ2V0UnVudGltZVJlbW90ZXMgPSBnZXRSdW50aW1lUmVtb3Rlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFJ1bnRpbWVSZW1vdGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@module-federation/utilities/src/utils/getRuntimeRemotes.js\n"));

/***/ }),

/***/ "../../node_modules/@module-federation/utilities/src/utils/importDelegatedModule.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@module-federation/utilities/src/utils/importDelegatedModule.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.importDelegatedModule = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"../../node_modules/tslib/tslib.es6.js\");\nconst common_1 = __webpack_require__(/*! ./common */ \"../../node_modules/@module-federation/utilities/src/utils/common.js\");\nconst importDelegatedModule = (keyOrRuntimeRemoteItem) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {\n    // @ts-ignore\n    return (0, common_1.loadScript)(keyOrRuntimeRemoteItem)\n        .then((asyncContainer) => {\n        return asyncContainer;\n    })\n        .then((asyncContainer) => {\n        // most of this is only needed because of legacy promise based implementation\n        // can remove proxies once we remove promise based implementations\n        if (typeof window === 'undefined') {\n            if (!Object.hasOwnProperty.call(keyOrRuntimeRemoteItem, 'global')) {\n                return asyncContainer;\n            }\n            // return asyncContainer;\n            //TODO: need to solve chunk flushing with delegated modules\n            return {\n                get: function (arg) {\n                    //@ts-ignore\n                    return asyncContainer.get(arg).then((f) => {\n                        const m = f();\n                        const result = {\n                            __esModule: m.__esModule,\n                        };\n                        for (const prop in m) {\n                            if (typeof m[prop] === 'function') {\n                                Object.defineProperty(result, prop, {\n                                    get: function () {\n                                        return function () {\n                                            //@ts-ignore\n                                            if (globalThis.usedChunks)\n                                                //@ts-ignore\n                                                globalThis.usedChunks.add(\n                                                //@ts-ignore\n                                                `${keyOrRuntimeRemoteItem.global}->${arg}`);\n                                            //eslint-disable-next-line prefer-rest-params\n                                            return m[prop](...arguments);\n                                        };\n                                    },\n                                    enumerable: true,\n                                });\n                            }\n                            else {\n                                Object.defineProperty(result, prop, {\n                                    get: () => {\n                                        //@ts-ignore\n                                        if (globalThis.usedChunks)\n                                            //@ts-ignore\n                                            globalThis.usedChunks.add(\n                                            //@ts-ignore\n                                            `${keyOrRuntimeRemoteItem.global}->${arg}`);\n                                        return m[prop];\n                                    },\n                                    enumerable: true,\n                                });\n                            }\n                        }\n                        if (m.then) {\n                            return Promise.resolve(() => result);\n                        }\n                        return () => result;\n                    });\n                },\n                init: asyncContainer.init,\n            };\n        }\n        else {\n            return asyncContainer;\n        }\n    });\n});\nexports.importDelegatedModule = importDelegatedModule;\n//# sourceMappingURL=importDelegatedModule.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi91dGlsaXRpZXMvc3JjL3V0aWxzL2ltcG9ydERlbGVnYXRlZE1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0IsZ0JBQWdCLG1CQUFPLENBQUMsb0RBQU87QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMscUZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsOEJBQThCLElBQUksSUFBSTtBQUN6RjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDhCQUE4QixJQUFJLElBQUk7QUFDckY7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi91dGlsaXRpZXMvc3JjL3V0aWxzL2ltcG9ydERlbGVnYXRlZE1vZHVsZS5qcz8yNTk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbXBvcnREZWxlZ2F0ZWRNb2R1bGUgPSB2b2lkIDA7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG5jb25zdCBpbXBvcnREZWxlZ2F0ZWRNb2R1bGUgPSAoa2V5T3JSdW50aW1lUmVtb3RlSXRlbSkgPT4gdHNsaWJfMS5fX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuICgwLCBjb21tb25fMS5sb2FkU2NyaXB0KShrZXlPclJ1bnRpbWVSZW1vdGVJdGVtKVxuICAgICAgICAudGhlbigoYXN5bmNDb250YWluZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGFzeW5jQ29udGFpbmVyO1xuICAgIH0pXG4gICAgICAgIC50aGVuKChhc3luY0NvbnRhaW5lcikgPT4ge1xuICAgICAgICAvLyBtb3N0IG9mIHRoaXMgaXMgb25seSBuZWVkZWQgYmVjYXVzZSBvZiBsZWdhY3kgcHJvbWlzZSBiYXNlZCBpbXBsZW1lbnRhdGlvblxuICAgICAgICAvLyBjYW4gcmVtb3ZlIHByb3hpZXMgb25jZSB3ZSByZW1vdmUgcHJvbWlzZSBiYXNlZCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGtleU9yUnVudGltZVJlbW90ZUl0ZW0sICdnbG9iYWwnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3luY0NvbnRhaW5lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiBhc3luY0NvbnRhaW5lcjtcbiAgICAgICAgICAgIC8vVE9ETzogbmVlZCB0byBzb2x2ZSBjaHVuayBmbHVzaGluZyB3aXRoIGRlbGVnYXRlZCBtb2R1bGVzXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzeW5jQ29udGFpbmVyLmdldChhcmcpLnRoZW4oKGYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBmKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19lc01vZHVsZTogbS5fX2VzTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtW3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIHByb3AsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsVGhpcy51c2VkQ2h1bmtzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLnVzZWRDaHVua3MuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtrZXlPclJ1bnRpbWVSZW1vdGVJdGVtLmdsb2JhbH0tPiR7YXJnfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1bcHJvcF0oLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgcHJvcCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdsb2JhbFRoaXMudXNlZENodW5rcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMudXNlZENodW5rcy5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtrZXlPclJ1bnRpbWVSZW1vdGVJdGVtLmdsb2JhbH0tPiR7YXJnfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLnRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCgpID0+IHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluaXQ6IGFzeW5jQ29udGFpbmVyLmluaXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcbmV4cG9ydHMuaW1wb3J0RGVsZWdhdGVkTW9kdWxlID0gaW1wb3J0RGVsZWdhdGVkTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1wb3J0RGVsZWdhdGVkTW9kdWxlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@module-federation/utilities/src/utils/importDelegatedModule.js\n"));

/***/ })

}]);